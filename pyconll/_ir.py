"""
Internal module to support dynamic code generation. The term IR is borrowed from compiler theory
here. Although it does not exactly describe what is being done, it is used anyway as a short-hand
to refer to the concept of dynamic code generation done within the python process itself.
"""

import random
from string.templatelib import Interpolation, Template, convert
from types import CodeType
from typing import Any

_used_name_ids: set[str] = set()
"""
This is to avoid a type of misuse of unique_name_id whereby the name is generated by not put onto
the namespace immediately. In this way, we never generate the same id twice in a program and it
also is not in a prepopulated namespace either.
"""


def unique_name_id(namespace: dict[str, Any], prefix: str) -> str:
    """
    Create a unique name identifier for the given namespace.

    Args:
        namespace: The namespace to create the new id in.
        prefix: The prefix that the name will have (along with a random suffix).

    Returns:
        The uniquely generated name.
    """
    var_name = ""
    suffix = -1
    while suffix < 0 or var_name in namespace or var_name in _used_name_ids:
        suffix = random.randint(0, 4294967296)
        var_name = f"{prefix}_{suffix}"
    _used_name_ids.add(var_name)

    return var_name


def process_ir(code: Template) -> CodeType:
    """
    Check the code for safety and compile it with the expected optimizations and configurations.

    Args:
        code: The code string to process.

    Returns:
        The compiled code in the case it was safely processed.

    Raises:
        RuntimeError: If the dynamic code did not match the safety requirements.
    """
    safe_ir = _safe_to_str(code)
    rooted = _root_ir(safe_ir)
    return compile(rooted, "<string>", "exec", optimize=2)


def _safe_to_str(template: Template) -> str:
    parts = []
    for item in template:
        match item:
            case str() as s:
                parts.append(s)
            case Interpolation(interpolated_value, _, conversion, format_spec):
                explicit_type = None
                match interpolated_value:
                    case (value, explicit_type):
                        ...
                    case _:
                        value = interpolated_value

                inferred_type = None
                pre_interpolation_op = None
                if format_spec == "t":
                    inferred_type = Template
                    pre_interpolation_op = _safe_to_str

                if (
                    inferred_type is not None
                    and explicit_type is not None
                    and explicit_type != inferred_type
                ):
                    raise RuntimeError(
                        "If an explicit type is provided along with an inferred type, they must "
                        "match."
                    )

                desired_type = inferred_type or explicit_type or str
                if type(value) != desired_type:  # pylint: disable=unidiomatic-typecheck
                    raise RuntimeError(
                        f"The type of the value {type(value)} does not match the desired "
                        f"{desired_type}."
                    )

                if pre_interpolation_op is not None:
                    value = pre_interpolation_op(value)
                value = convert(value, conversion)
                if pre_interpolation_op is None:
                    value = format(value, format_spec)

                parts.append(value)

    return "".join(parts)


def _root_ir(code: str) -> str:
    """
    Transform the indentation levels of some Python code to have no indentation.

    This is mostly a helper method to allow for easier inline dynamic code creation without
    requiring these strings to have indentation out of sync with the code it is defined with.

    Args:
        code: The code to transform.

    Returns:
        The rooted code with no base indentation.
    """
    lines = code.split("\n")
    if not lines:
        return code

    for first, line in enumerate(lines):
        if line:
            break
    else:
        return code

    prefix_chars = []
    for ch in lines[first]:
        if ch not in " \t":
            break
        if ch != lines[first][0]:
            raise RuntimeError("Inconsistent whitespace usage in IR being reformatted.")

        prefix_chars.append(ch)
    prefix = "".join(prefix_chars)

    new_lines = [lines[first].removeprefix(prefix)]
    for line in lines[first + 1 :]:
        if not line:
            continue
        if not line.startswith(prefix):
            raise RuntimeError("Expected whitespace prefix not found on one of the IR lines.")

        new_lines.append(line.removeprefix(prefix))

    return "\n".join(new_lines)
