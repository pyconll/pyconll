"""
Internal module to support dynamic code generation. The term IR is borrowed from compiler theory
here. Although it does not exactly describe what is being done, it is used anyway as a short-hand
to refer to the concept of dynamic code generation done within the python process itself.
"""

import random
from string.templatelib import Interpolation, Template
from types import CodeType
from typing import Any

_used_name_ids: set[str] = set()
"""
This is to avoid a type of misuse of unique_name_id whereby the name is generated by not put onto
the namespace immediately. In this way, we never generate the same id twice in a program and it
also is not in a prepopulated namespace either.
"""


def unique_name_id(namespace: dict[str, Any], prefix: str) -> str:
    """
    Create a unique name identifier for the given namespace.

    Args:
        namespace: The namespace to create the new id in.
        prefix: The prefix that the name will have (along with a random suffix).

    Returns:
        The uniquely generated name.
    """
    var_name = ""
    suffix = -1
    while suffix < 0 or var_name in namespace or var_name in _used_name_ids:
        suffix = random.randint(0, 4294967296)
        var_name = f"{prefix}_{suffix}"
    _used_name_ids.add(var_name)

    return var_name


def process_ir(code: Template) -> CodeType:
    """
    TODO:
    """
    for value in code.values:
        if type(value) not in (str, bool, int):
            raise RuntimeError(
                "For safety purposes, only basic, or builtin types can be provided as IR "
                f"formatters and an object of type {type(value)} was passed in."
            )

    str_ir = _to_str(code)
    rooted = _root_ir(str_ir)
    return compile(rooted, "<string>", "exec", optimize=2)


def _to_str(template: Template) -> str:
    parts = []
    for item in template:
        match item:
            case str() as s:
                parts.append(s)
            case Interpolation(value, _, conversion, format_spec):
                if conversion == "a":
                    value = ascii(value)
                elif conversion == "r":
                    value = repr(value)
                elif conversion == "s":
                    value = str(value)

                value = format(value, format_spec)
                parts.append(value)
    return "".join(parts)


def _root_ir(code: str) -> str:
    """
    Transform the indentation levels of some Python code to have no indentation.

    This is mostly a helper method to allow for easier inline dynamic code creation without
    requiring these strings to have indentation out of sync with the code it is defined with.

    Args:
        code: The code to transform.

    Returns:
        The rooted code with no base indentation.
    """
    lines = code.split("\n")
    if not lines:
        return code

    for first, line in enumerate(lines):
        if line:
            break
    else:
        return code

    prefix_chars = []
    for ch in lines[first]:
        if ch not in " \t":
            break
        if ch != lines[first][0]:
            raise RuntimeError("Inconsistent whitespace usage in IR being reformatted.")

        prefix_chars.append(ch)
    prefix = "".join(prefix_chars)

    new_lines = [lines[first].removeprefix(prefix)]
    for line in lines[first + 1 :]:
        if not line:
            continue
        if not line.startswith(prefix):
            raise RuntimeError("Expected whitespace prefix not found on one of the IR lines.")

        new_lines.append(line.removeprefix(prefix))

    return "\n".join(new_lines)
